#include <iostream>
#include "DhcpMessage.hpp"
#include "NetworkInterface.hpp"
#include "UdpListener.hpp"

#include <boost/asio.hpp>
#include <boost/algorithm/algorithm.hpp>
#include <boost/property_tree/json_parser.hpp>


// здесь можно производить отладку
int main(){
    auto ifaces = get_all_interfaces();
    for (auto &iface : ifaces){
        if (iface.type == L3AddressType::IPv4){
            std::cout << iface.name << ": " << std::get<IPv4Address>(iface.network_address).to_string()
                << "/" << std::get<IPv4SubnetMask>(iface.subnet_mask).to_prefix()
                << "  " << iface.mac_address.to_string() <<"\n";
        }
    }
    std::vector<uint8_t> test_dhcp_message_data = {
        0x02, 0x01, 0x06, 0x00, // op, htype, hlen, hops
        0x07, 0xd0, 0xd9, 0x0d, // xid
        0x00, 0x01, 0x00, 0x00, // secs (2), flags (2)
        0x00, 0x00, 0x00, 0x00, // ciaddr
        0xc0, 0xa8, 0x01, 0x0a, // yiaddr
        0xc0, 0xa8, 0x01, 0x01, // siaddr
        0x00, 0x00, 0x00, 0x00, // giaddr
        0x38, 0x01, 0x22, 0xe4, 0xb2, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // chaddr (16)
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // sname
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // end sname
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // file
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ...
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // end file
        0x63, 0x82, 0x53, 0x63, // magic cookie
        0x35, 0x01, 0x05,  // (53) DHCP Message Type
        0x36, 0x04, 0xc0, 0xa8, 0x01, 0x01, // (54) server id
        0x33, 0x04, 0x00, 0x00, 0xa8, 0xc0, // (51) IP Address Lease Time
        0x3a, 0x04, 0x00, 0x00, 0x54, 0x60, // (58) Renewal (T1) Time Value
        0x3b, 0x04, 0x00, 0x00, 0x93, 0xa8, // (59) Rebinding (T2) Time Value
        0x01, 0x04, 0xff, 0xff, 0xff, 0x00, // (1) Subnet Mask
        0x1c, 0x04, 0xc0, 0xa8, 0x01, 0xff, // (28) Broadcast Address Option
        0x03, 0x04, 0xc0, 0xa8, 0x01, 0x01, // (3) Router Option
        0x06, 0x04, 0xc0, 0xa8, 0x01, 0x01, // (6) DNS
        0x0c, 0x0c, 0x69, 0x74, 0x2d, 0x6e, 0x6f, 0x74, 0x2d, 0x61, 0x2d, 0x70, 0x72, 0x6f, // (12) Hostname
        0xff
    };
    DhcpMessage test_dhcp_message(test_dhcp_message_data);
    UdpServer udp_listener(67);
    std::cout << "DHCP server started\n";
    //wireshark filter udp.payload == 64:63:62:61:60:5f:5e:5d:5c:5b:5a
    udp_listener.send_to({100, 99, 98, 97, 96,95,94,93,92,91,90});
    while(true){
        if (udp_listener.is_input_queue_blank()){
            continue;
        }
        auto packet = udp_listener.get_next_datagram();
        std::cout << "received datagram length " << packet.size() << "\n";
        DhcpMessage dhcp_packet(packet);
        std::cout << dhcp_packet.yiaddr.to_string() << "\n";
        for (auto option : dhcp_packet.options){
            std::cout << option.description.code << "\n";
        }
    }
}
